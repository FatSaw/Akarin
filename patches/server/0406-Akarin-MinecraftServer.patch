From 73904475aeea08a207a5ce442f4bf574a50b593d Mon Sep 17 00:00:00 2001
From: Yiyu Si <1486864380@qq.com>
Date: Sat, 20 Aug 2022 10:28:43 +0800
Subject: [PATCH] Akarin MinecraftServer


diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 3b982f990..d7810b1a8 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -49,6 +49,21 @@ import org.bukkit.craftbukkit.Main;
 // CraftBukkit end
 import org.spigotmc.SlackActivityAccountant; // Spigot
 import co.aikar.timings.MinecraftTimings; // Paper
+//Akarin Start
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorCompletionService;
+import org.apache.commons.lang.WordUtils;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
+import org.bukkit.event.inventory.InventoryMoveItemEvent;
+import org.bukkit.event.world.WorldLoadEvent;
+import io.akarin.api.internal.Akari;
+import io.akarin.api.internal.Akari.AssignableFactory;
+import io.akarin.api.internal.mixin.IMixinWorldServer;
+import io.akarin.server.core.AkarinGlobalConfig;
+import io.akarin.server.core.AkarinSlackScheduler;
+//Akarin End
 
 public abstract class MinecraftServer implements ICommandListener, Runnable, IAsyncTaskHandler, IMojangStatistics {
 
@@ -124,6 +139,10 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
     // Spigot start
     public final SlackActivityAccountant slackActivityAccountant = new SlackActivityAccountant();
     // Spigot end
+    //Akarin Start
+    private boolean tickedPrimaryEntities;
+	private int cachedWorldSize;
+    // Akarin End
 
     public MinecraftServer(OptionSet options, Proxy proxy, DataConverterManager dataconvertermanager, YggdrasilAuthenticationService yggdrasilauthenticationservice, MinecraftSessionService minecraftsessionservice, GameProfileRepository gameprofilerepository, UserCache usercache) {
         SERVER = this; // Paper - better singleton
@@ -355,54 +374,55 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
         // Paper end
     }
 
-    protected void l() {
-        boolean flag = true;
-        boolean flag1 = true;
-        boolean flag2 = true;
-        boolean flag3 = true;
-        int i = 0;
-
-        this.b("menu.generatingTerrain");
-        boolean flag4 = false;
-
-        // CraftBukkit start - fire WorldLoadEvent and handle whether or not to keep the spawn in memory
-        for (int m = 0; m < worlds.size(); m++) {
-            WorldServer worldserver = this.worlds.get(m);
-            MinecraftServer.LOGGER.info("Preparing start region for level " + m + " (Seed: " + worldserver.getSeed() + ")");
-
-            if (!worldserver.getWorld().getKeepSpawnInMemory()) {
-                continue;
-            }
-
-            BlockPosition blockposition = worldserver.getSpawn();
-            long j = aw();
-            i = 0;
-
-            // Paper start
-            short radius = worldserver.paperConfig.keepLoadedRange;
-            for (int k = -radius; k <= radius && this.isRunning(); k += 16) {
-                for (int l = -radius; l <= radius && this.isRunning(); l += 16) {
-            // Paper end
-                    long i1 = aw();
-
-                    if (i1 - j > 1000L) {
-                        this.a_("Preparing spawn area", i * 100 / 625);
-                        j = i1;
-                    }
-
-                    ++i;
-                    worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+    //Akarin Start
+
+    private void prepareChunks(WorldServer world, int index) {
+        MinecraftServer.LOGGER.info("Preparing start region for level " + index + " (Seed: " + world.getSeed() + ")");
+        BlockPosition spawnPos = world.getSpawn();
+        long lastRecord = System.currentTimeMillis();
+        
+        int preparedChunks = 0;
+        short radius = world.paperConfig.keepLoadedRange;
+        for (int skipX = -radius; skipX <= radius && isRunning(); skipX += 16) {
+            for (int skipZ = -radius; skipZ <= radius && isRunning(); skipZ += 16) {
+                long now = System.currentTimeMillis();
+                
+                if (now - lastRecord > 1000L) {
+                    a_("Preparing spawn area (level " + index + ") ", preparedChunks * 100 / 625);
+                    lastRecord = now;
                 }
+                
+                preparedChunks++;
+                world.getChunkProviderServer().getChunkAt(spawnPos.getX() + skipX >> 4, spawnPos.getZ() + skipZ >> 4);
             }
         }
+    }
 
+    protected void l() throws InterruptedException {
+        ExecutorCompletionService<?> executor = new ExecutorCompletionService<>(Executors.newFixedThreadPool(worlds.size(), new AssignableFactory("Akarin Parallel Terrain Generation Thread - $")));
+        
+        for (int index = 0; index < worlds.size(); index++) {
+            WorldServer world = this.worlds.get(index);
+            if (!world.getWorld().getKeepSpawnInMemory()) continue;
+            
+            int fIndex = index;
+            executor.submit(() -> prepareChunks(world, fIndex), null);
+        }
+        
         for (WorldServer world : this.worlds) {
-            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(world.getWorld()));
+            if (world.getWorld().getKeepSpawnInMemory()) executor.take();
         }
-        // CraftBukkit end
-        this.t();
+        if (WorldLoadEvent.getHandlerList().getRegisteredListeners().length != 0) {
+            for (WorldServer world : this.worlds) {
+                this.server.getPluginManager().callEvent(new WorldLoadEvent(world.getWorld()));
+            }
+        }
+        
+        t();
     }
 
+    //Akarin End
+
     protected void a(String s, IDataManager idatamanager) {
         File file = new File(idatamanager.getDirectory(), "resources.zip");
 
@@ -614,6 +634,17 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
     public void run() {
         try {
             if (this.init()) {
+                //Akarin Start
+                primaryThread.setPriority(AkarinGlobalConfig.primaryThreadPriority < Thread.NORM_PRIORITY ? Thread.NORM_PRIORITY :
+                    (AkarinGlobalConfig.primaryThreadPriority > Thread.MAX_PRIORITY ? 10 : AkarinGlobalConfig.primaryThreadPriority));
+                Akari.resizeTickExecutors((cachedWorldSize = worlds.size()));
+            
+                for (int i = 0; i < worlds.size(); ++i) {
+                    WorldServer world = worlds.get(i);
+                    //TileEntityHopper.skipHopperEvents = world.paperConfig.disableHopperMoveEvents || InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0;
+                }
+                AkarinSlackScheduler.get().boot();
+                //Akarin End
                 this.ab = aw();
                 long i = 0L;
 
@@ -835,136 +866,175 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
     }
 
-    public void D() {
-        MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Paper
-        this.server.getScheduler().mainThreadHeartbeat(this.ticks); // CraftBukkit
-        MinecraftTimings.bukkitSchedulerTimer.stopTiming(); // Paper
-        MinecraftTimings.minecraftSchedulerTimer.startTiming(); // Paper
-        this.methodProfiler.a("jobs");
-        Queue queue = this.j;
-
-        // Spigot start
-        FutureTask<?> entry;
-        int count = this.j.size();
-        while (count-- > 0 && (entry = this.j.poll()) != null) {
-            SystemUtils.a(entry, MinecraftServer.LOGGER);
-         }
-        // Spigot end
-        MinecraftTimings.minecraftSchedulerTimer.stopTiming(); // Paper
-
-        this.methodProfiler.c("levels");
-
-        // CraftBukkit start
-        // Run tasks that are waiting on processing
-        MinecraftTimings.processQueueTimer.startTiming(); // Spigot
-        while (!processQueue.isEmpty()) {
-            processQueue.remove().run();
-        }
-        MinecraftTimings.processQueueTimer.stopTiming(); // Spigot
-
-        MinecraftTimings.chunkIOTickTimer.startTiming(); // Spigot
-        org.bukkit.craftbukkit.chunkio.ChunkIOExecutor.tick();
-        MinecraftTimings.chunkIOTickTimer.stopTiming(); // Spigot
-
-        MinecraftTimings.timeUpdateTimer.startTiming(); // Spigot
-        // Send time updates to everyone, it will get the right time from the world the player is in.
-        if (this.ticks % 20 == 0) {
-            for (int i = 0; i < this.getPlayerList().players.size(); ++i) {
-                EntityPlayer entityplayer = (EntityPlayer) this.getPlayerList().players.get(i);
-                entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateTime(entityplayer.world.getTime(), entityplayer.getPlayerTime(), entityplayer.world.getGameRules().getBoolean("doDaylightCycle"))); // Add support for per player time
+    //Akarin Start
+    private boolean tickEntities(WorldServer world) {
+        try {
+            world.timings.tickEntities.startTiming();
+            world.tickEntities();
+            world.timings.tickEntities.stopTiming();
+            world.getTracker().updatePlayers();
+            world.explosionDensityCache.clear(); // Paper - Optimize explosions
+        } catch (Throwable throwable) {
+            CrashReport crashreport;
+            try {
+                crashreport = CrashReport.a(throwable, "Exception ticking world entities");
+            } catch (Throwable t){
+                throw new RuntimeException("Error generating crash report", t);
             }
+            world.a(crashreport);
+            throw new ReportedException(crashreport);
         }
-        MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot
-
-        int i;
-
-        for (i = 0; i < this.worlds.size(); ++i) { // CraftBukkit
-            long j = System.nanoTime();
+        return true;
+    }
 
-            // if (i == 0 || this.getAllowNether()) {
-                WorldServer worldserver = this.worlds.get(i);
-                TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0;
+    private void tickWorld(WorldServer world) {
+        try {
+            world.timings.doTick.startTiming();
+            world.doTick();
+            world.timings.doTick.stopTiming();
+        } catch (Throwable throwable) {
+            CrashReport crashreport;
+            try {
+                crashreport = CrashReport.a(throwable, "Exception ticking world");
+            } catch (Throwable t){
+                throw new RuntimeException("Error generating crash report", t);
+            }
+            world.a(crashreport);
+            throw new ReportedException(crashreport);
+        }
+    }
 
-                this.methodProfiler.a(() -> {
-                    return worldserver.getWorldData().getName();
-                });
-                /* Drop global time updates
-                if (this.ticks % 20 == 0) {
-                    this.methodProfiler.a("timeSync");
-                    this.v.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean("doDaylightCycle"))), worldserver.worldProvider.getDimensionManager().getDimensionID());
-                    this.methodProfiler.b();
+    public void D() throws InterruptedException, ExecutionException, CancellationException {
+        Runnable runnable;
+        Akari.callbackTiming.startTiming();
+        while ((runnable = Akari.callbackQueue.poll()) != null) runnable.run();
+        Akari.callbackTiming.stopTiming();
+        
+        MinecraftTimings.bukkitSchedulerTimer.startTiming();
+        this.server.getScheduler().mainThreadHeartbeat(this.ticks);
+        MinecraftTimings.bukkitSchedulerTimer.stopTiming();
+        
+        MinecraftTimings.minecraftSchedulerTimer.startTiming();
+        FutureTask<?> task;
+        int count = j.size();
+        while (count-- > 0 && (task = j.poll()) != null) {
+            SystemUtils.a(task, MinecraftServer.LOGGER);
+        }
+        MinecraftTimings.minecraftSchedulerTimer.stopTiming();
+        
+        MinecraftTimings.processQueueTimer.startTiming();
+        while ((runnable = processQueue.poll()) != null) runnable.run();
+        MinecraftTimings.processQueueTimer.stopTiming();
+        
+        MinecraftTimings.chunkIOTickTimer.startTiming();
+        ChunkIOExecutor.tick();
+        MinecraftTimings.chunkIOTickTimer.stopTiming();
+        
+        if (cachedWorldSize != worlds.size()) Akari.resizeTickExecutors((cachedWorldSize = worlds.size()));
+        switch (AkarinGlobalConfig.parallelMode) {
+            case 1:
+            case 2:
+            default:
+                // Never tick one world concurrently!
+                for (int i = 0; i < cachedWorldSize; i++) {
+                    // Impl Note:
+                    // Entities ticking: index 1 -> ... -> 0 (parallel)
+                    //   World  ticking: index 0 -> ... (parallel)
+                    int interlace = i + 1;
+                    WorldServer entityWorld = worlds.get(interlace < cachedWorldSize ? interlace : 0);
+                    Akari.STAGE_TICK.submit(() -> {
+                        synchronized (((IMixinWorldServer) entityWorld).lock()) {
+                            tickEntities(entityWorld);
+                        }
+                    }, null/*new TimingSignal(entityWorld, true)*/);
+                    
+                    if (AkarinGlobalConfig.parallelMode != 1) {
+                        int fi = i;
+                        Akari.STAGE_TICK.submit(() -> {
+                            WorldServer world = worlds.get(fi);
+                            synchronized (((IMixinWorldServer) world).lock()) {
+                                tickWorld(world);
+                            }
+                        }, null);
+                    }
                 }
-                // CraftBukkit end */
-
-                this.methodProfiler.a("tick");
-
-                CrashReport crashreport;
-
-                try {
-                    worldserver.timings.doTick.startTiming(); // Spigot
-                    worldserver.doTick();
-                    worldserver.timings.doTick.stopTiming(); // Spigot
-                } catch (Throwable throwable) {
-                    // Spigot Start
-                    try {
-                    crashreport = CrashReport.a(throwable, "Exception ticking world");
-                    } catch (Throwable t){
-                        throw new RuntimeException("Error generating crash report", t);
+                
+                if (AkarinGlobalConfig.parallelMode == 1)
+                Akari.STAGE_TICK.submit(() -> {
+                    for (int i = 0; i < cachedWorldSize; i++) {
+                        WorldServer world = worlds.get(i);
+                        synchronized (((IMixinWorldServer) world).lock()) {
+                            tickWorld(world);
+                        }
                     }
-                    // Spigot End
-                    worldserver.a(crashreport);
-                    throw new ReportedException(crashreport);
+                }, null);
+                
+                for (int i = (AkarinGlobalConfig.parallelMode == 1 ? cachedWorldSize + 1 : cachedWorldSize * 2); i --> 0 ;) {
+                    Akari.STAGE_TICK.take();
                 }
-
-                try {
-                    worldserver.timings.tickEntities.startTiming(); // Spigot
-                    worldserver.tickEntities();
-                    worldserver.timings.tickEntities.stopTiming(); // Spigot
-                } catch (Throwable throwable1) {
-                    // Spigot Start
-                    try {
-                    crashreport = CrashReport.a(throwable1, "Exception ticking world entities");
-                    } catch (Throwable t){
-                        throw new RuntimeException("Error generating crash report", t);
+                
+                /* for (int i = (AkarinGlobalConfig.parallelMode == 1 ? cachedWorldSize : cachedWorldSize * 2); i --> 0 ;) {
+                    long startTiming = System.nanoTime();
+                    TimingSignal signal = Akari.STAGE_TICK.take().get();
+                    IMixinTimingHandler timing = (IMixinTimingHandler) (signal.isEntities ? signal.tickedWorld.timings.tickEntities : signal.tickedWorld.timings.doTick);
+                    timing.stopTiming(startTiming); // The overlap will be ignored
+                } */
+                
+                break;
+            case 0:
+                Akari.STAGE_TICK.submit(() -> {
+                    for (int i = 1; i <= cachedWorldSize; ++i) {
+                        WorldServer world = worlds.get(i < cachedWorldSize ? i : 0);
+                        synchronized (((IMixinWorldServer) world).lock()) {
+                            tickEntities(world);
+                        }
+                    }
+                }, null);
+                
+                Akari.STAGE_TICK.submit(() -> {
+                    for (int i = 0; i < cachedWorldSize; ++i) {
+                        WorldServer world = worlds.get(i);
+                        synchronized (((IMixinWorldServer) world).lock()) {
+                            tickWorld(world);
+                        }
                     }
-                    // Spigot End
-                    worldserver.a(crashreport);
-                    throw new ReportedException(crashreport);
+                }, null);
+                
+                Akari.STAGE_TICK.take();
+                Akari.STAGE_TICK.take();
+                break;
+            case -1:
+                for (int i = 0; i < cachedWorldSize; ++i) {
+                    WorldServer world = worlds.get(i);
+                    tickWorld(world);
+                    tickEntities(world);
                 }
-
-                this.methodProfiler.b();
-                this.methodProfiler.a("tracker");
-                worldserver.getTracker().updatePlayers();
-                this.methodProfiler.b();
-                this.methodProfiler.b();
-                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
-            // } // CraftBukkit
-
-            // this.i[i][this.ticks % 100] = System.nanoTime() - j; // CraftBukkit
+                break;
         }
-
-        this.methodProfiler.c("connection");
-        MinecraftTimings.connectionTimer.startTiming(); // Spigot
-        this.an().c();
-        MinecraftTimings.connectionTimer.stopTiming(); // Spigot
-        this.methodProfiler.c("players");
-        MinecraftTimings.playerListTimer.startTiming(); // Spigot
-        this.v.tick();
-        MinecraftTimings.playerListTimer.stopTiming(); // Spigot
-        this.methodProfiler.c("commandFunctions");
-        MinecraftTimings.commandFunctionsTimer.startTiming(); // Spigot
-        this.aL().e();
-        MinecraftTimings.commandFunctionsTimer.stopTiming(); // Spigot
-        this.methodProfiler.c("tickables");
-
-        MinecraftTimings.tickablesTimer.startTiming(); // Spigot
-        for (i = 0; i < this.o.size(); ++i) {
-            ((ITickable) this.o.get(i)).e();
+        
+        Akari.callbackTiming.startTiming();
+        while ((runnable = Akari.callbackQueue.poll()) != null) runnable.run();
+        Akari.callbackTiming.stopTiming();
+        
+        MinecraftTimings.connectionTimer.startTiming();
+        an().c();
+        MinecraftTimings.connectionTimer.stopTiming();
+        
+        Akari.callbackTiming.startTiming();
+        while ((runnable = Akari.callbackQueue.poll()) != null) runnable.run();
+        Akari.callbackTiming.stopTiming();
+        
+        MinecraftTimings.commandFunctionsTimer.startTiming();
+        aL().e();
+        MinecraftTimings.commandFunctionsTimer.stopTiming();
+        
+        MinecraftTimings.tickablesTimer.startTiming();
+        for (int i = 0; i < this.o.size(); ++i) {
+            o.get(i).e();
         }
-        MinecraftTimings.tickablesTimer.stopTiming(); // Spigot
-
-        this.methodProfiler.b();
+        MinecraftTimings.tickablesTimer.stopTiming();
     }
+    //Akarin End
 
     public boolean getAllowNether() {
         return true;
@@ -1156,7 +1226,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
     }
 
     public String getServerModName() {
-        return "Paper"; //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Akarin"; //Akarin - Akarin > //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1348,7 +1418,13 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
         this.P = s1;
     }
 
+    /*
+     * Akarin
+     * Forcely disable snooper
+     */
+
     public void a(MojangStatisticsGenerator mojangstatisticsgenerator) {
+    /*
         mojangstatisticsgenerator.a("whitelist_enabled", Boolean.valueOf(false));
         mojangstatisticsgenerator.a("whitelist_count", Integer.valueOf(0));
         if (this.v != null) {
@@ -1385,13 +1461,16 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
         }
 
         mojangstatisticsgenerator.a("worlds", Integer.valueOf(i));
+    */
     }
 
     public void b(MojangStatisticsGenerator mojangstatisticsgenerator) {
+    /*
         mojangstatisticsgenerator.b("singleplayer", Boolean.valueOf(this.R()));
         mojangstatisticsgenerator.b("server_brand", this.getServerModName());
         mojangstatisticsgenerator.b("gui_supported", GraphicsEnvironment.isHeadless() ? "headless" : "supported");
         mojangstatisticsgenerator.b("dedicated", Boolean.valueOf(this.aa()));
+    */
     }
 
     public boolean getSnooperEnabled() {
@@ -1628,7 +1707,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
     }
 
     public boolean isMainThread() {
-        return Thread.currentThread() == this.serverThread;
+        return Akari.isPrimaryThread(); //Akarin
     }
 
     public int aG() {
-- 
2.35.1.windows.2

